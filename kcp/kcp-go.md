# kcp-go
golang으로 만든 kcp 구현체   
[GitHub](https://github.com/xtaci/kcp-go )  
  
아래 글은 GitHub 저장소에 있는 내용을 번역한 것이다.  

# 소개
kcp-go는 golang을 위한 프로덕션급 신뢰성-UDP 라이브러리이다.  
  
이 라이브러리는 UDP 패킷을 통한 스트림의 원활하고 탄력적이며 정돈되고 오류가 확인된 익명 전송을 제공하기 위한 것으로,  오픈소스 프로젝트인 [kcptun](https://github.com/xtaci/kcptun )을 통해 실전 테스트를 거쳤다. 로우엔드 MIPS 라우터부터 하이엔드 서버에 이르기까지 수백만 개의 디바이스가 온라인 게임, 라이브 방송, 파일 동기화, 네트워크 가속 등 다양한 형태로 kcp-go 기반 프로그램을 배포했다.
    

# Features  
1. 지연 시간에 민감한 시나리오를 위해 설계 되었다.
2. 캐시 친화적이고 메모리에 최적화된 설계로 매우 높은 성능의 코어를 제공한다.  
3. 단일 상품 서버에서 5K 이상의 동시 연결을 처리한다.  
4. net.TCPConn의 드롭인 대체품인 net.Conn 및 net.Listener와 호환된다.
5. [리드-솔로몬 코드](https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction )를 통한 [FEC(순방향 오류 수정)](https://en.wikipedia.org/wiki/Forward_error_correction) 지원
6. 완전히 익명의 패킷을 생성하는 CFB 모드에서 AES, TEA, 3DES, Blowfish, Cast5, Salsa20 등의 패킷 수준 암호화를 지원한다.  
7. 전체 서버 애플리케이션에 대해 고정된 수의 고루틴만 생성되며, 고루틴 간 컨텍스트 전환 비용이 고려 되었다.
8. 다양한 개선 사항으로 skywind3000의 C 버전과 호환된다.
9. 플랫폼에 따른 최적화: 리눅스용 sendmmsg 및 recvmmsg가 익스플로잇 되었다. 


# Specification 
```
+-----------------+
| SESSION         |
+-----------------+
| KCP(ARQ)        |
+-----------------+
| FEC(OPTIONAL)   |
+-----------------+
| CRYPTO(OPTIONAL)|
+-----------------+
| UDP(PACKET)     |
+-----------------+
| IP              |
+-----------------+
| LINK            |
+-----------------+
| PHY             |
+-----------------+
(LAYER MODEL OF KCP-GO)
```  


# Key Design Considerations
1. 슬라이스 대 컨테이너/리스트
`kcp.flush()`는 20ms(간격)마다 재전송 확인을 위해 전송 대기열을 반복한다.  
슬라이스와 컨테이너/리스트를 통한 순차적 루프를 비교하는 벤치마크는 여기에 작성했다:  
https://github.com/xtaci/notes/blob/master/golang/benchmark2/cachemiss_test.go  
<pre>
BenchmarkLoopSlice-4 2000000000 0.39 ns/op
BenchmarkLoopList-4 100000000 54.6 ns/op
</pre>  
  
리스트 구조는 로컬리티가 더 좋은 슬라이스에 비해 캐시 누락이 심하며, 32개의 windows 크기와 20ms 간격으로 5000개의 연결에서 각각 `kcp.flush()` 하면 슬라이스를 사용하면 6us/0.03%(cpu), 리스트의 경우 8.7ms/43.5%(cpu)의 비용이 발생한다.  


2. 타이밍 정확도 대 시스템 호출 clock_gettime 비교
타이밍은 RTT 추정기에 매우 중요하며, 부정확한 타이밍은 KCP에서 잘못된 재전송으로 이어지지만, time.Now()를 호출하는데 42사이클(4GHz CPU에서 10.5ns, 내 MacBook Pro 2.7GHz에서 15.6ns)가 걸린다.  
  
time.Now()의 벤치마크는 여기에 있다:  
https://github.com/xtaci/notes/blob/master/golang/benchmark2/syscall_test.go  
<pre>  
BenchmarkNow-4 100000000 15.6 ns/op
</pre>  
  
kcp-go에서는 각 kcp.output() 함수 호출 후 반환 시 현재 시계 시간이 업데이트 되며, 단일 kcp.flush() 작업의 경우 현재 시간이 시스템에서 한 번 쿼리된다. 대부분의 경우 5000개의 연결은 5000 * 15.6ns = 78us(패킷을 전송할 필요가 없는 고정 비용)이며, 1400 MTU로 10MB/s의 데이터를 전송하는 경우, 매초마다 time.Now()가 약 7500회 호출되고 117us의 비용이 발생한다.
    
3. 메모리 관리
기본 메모리 할당은 글로벌 버퍼 풀 xmit.Buf에서 이루어지며, 일부 바이트를 할당해야 할 때 kcp-go에서 해당 풀에서 가져올 수 있으며, 고정 용량 1500 바이트(mtuLimit)가 반환되고, rx 큐, tx 큐 및 fec 큐는 모두 거기에서 바이트를 수신하고 사용 후 바이트를 풀로 반환하여 불필요한 바이트의 제로화를 방지한다. 풀 메커니즘은 슬라이스 객체에 대해 높은 워터마크를 유지했으며, 풀의 이러한 기내 객체는 주기적인 가비지 컬렉션에서 살아남는 한편, 유휴 상태일 경우 메모리를 런타임에 반환하는 기능을 유지했다.
  
4. 정보 보안
다양한 블록 암호화 알고리즘으로 구동되는 패킷 암호화가 내장되어 있으며 암호 피드백 모드에서 작동하는 kcp-go는 전송할 각 패킷에 대해 시스템 엔트로피에서 논스를 암호화하는 것부터 암호화 프로세스가 시작되므로 동일한 평문으로 암호화해도 그 이후에는 동일한 암호문이 생성되지 않는다.  
  
패킷의 내용은 헤더(FEC, KCP), 체크섬 및 내용을 포함하여 암호화를 통해 완전히 익명화된다. 상위 계층에서 어떤 암호화 방법을 선택하든 암호화를 비활성화하면 헤더가 모든 사람에게 일반 텍스트로 표시되므로 슬라이딩 윈도우 크기, 왕복 시간, FEC 속성 및 체크섬을 재밍하는 등의 헤더 변조에 취약해 전송이 어떻게든 안전하지 않게 된다는 점에 유의하자. 최신 CPU는 AES-NI 명령어와 함께 제공되며 salsa20보다 성능이 훨씬 뛰어나므로 최소한의 암호화를 위해 AES-128을 사용하는 것이 좋다(위 표 참조).  
  
kcp-go에 대한 다른 가능한 공격은 다음과 같다: a) 트래픽 분석, 특정 웹사이트의 데이터 흐름은 데이터를 교환하는 동안 패턴이 있을 수 있지만, 이러한 유형의 도청은 데이터 스트림을 혼합하여 노이즈를 도입하도록 스룩스를 조정함으로써 완화 되었으며, 이에 대한 완벽한 솔루션은 아직 나타나지 않았으며 이론적으로 대규모 네트워크에서 메시지를 셔플/믹싱하여 이 문제를 완화할 수 있다.  b) 리플레이 공격, 어떤 이유에서인지 kcp-go에 비대칭 암호화가 도입되지 않았기 때문에 패킷을 캡처하여 다른 컴퓨터에서 재생하는 것이 가능하므로(주의: 세션을 가로채서 내용을 복호화하는 것은 여전히 불가능) 상위 계층에는 각 메시지의 신뢰성을 보장하는(메시지를 정확히 한 번만 처리하는) 비대칭 암호화 시스템이 포함 되어야 하며, 요청에 개인 키로 서명하는 것만으로 이러한 유형의 공격을 제거할 수 있다.  


<br>  
     
# 연결 종료
TCP의 SYN/FIN/RST와 같은 제어 메시지는 KCP에 정의되어 있지 않으므로 애플리케이션 수준에서 일부 킵얼라이브/하트비트 메커니즘이 필요하다. 실제 예는 세션에 대한 멀티플렉싱 프로토콜인 [smux](https://github.com/xtaci/smux )(킵얼라이브 메커니즘이 내장된)를 사용하는 것이다(예: kcptun 참조).  
  
   
<br>     

# 자주 묻는 질문
Q: 서버에서 5,000개 이상의 연결을 처리하고 있는데 CPU 사용률이 너무 높다.  
  
A: CPU 사용률뿐만 아니라 재전송에 간접적으로 영향을 주는 RTT 측정(타이밍)의 정밀도를 위해서도 독립형 에이전트 또는 게이트 서버를 사용하는 것을 권장한다. conn.SetNoDelay(1, 40, 1, 1)과 같이 SetNoDelay로 업데이트 간격을 늘리면 시스템 부하를 크게 줄일 수 있지만 성능이 저하될 수 있다.  
  
<br> 
     
Q: FEC는 언제 활성화해야 하나요?
  
A: 장거리 전송에서는 패킷 손실이 발생하면 시간상 큰 불이익이 발생하므로 순방향 오류 수정이 매우 중요하다. 현대의 복잡한 패킷 라우팅 네트워크의 경우 왕복 시간 기반 손실 검사가 항상 효율적인 것은 아니며, 장거리에서 RTT 샘플의 편차가 크면 일반적으로 일반적인 RTO 추정기에서 더 큰 RTO 값이 발생하여 전송 속도가 느려진다.
  
<br> 

Q: 암호화를 활성화해야 하나요?

A: 예, 상위 계층이 암호화되어 있더라도 프로토콜의 안전을 위해 암호화를 활성화해야 한다.  