# KCP 스택
[출처](https://github.com/zsummer/knet/blob/master/doc/kcp_knowledge.md )
DeepL로 번역한 것을 정리한 것이다.  
  
## 개요 
KCP는 순수 ARQ 프로토콜 재전송 메커니즘을 통한 UDP 패킷의 안정적인 전송을 한다
- TCP에 비해 대역폭이 10~20% 낭비되는 대신 평균 지연 시간은 30~40% 감소하고 최대 지연 시간은 3배 감소한다.
- 순수 알고리즘 구현으로, 기본 프로토콜(예: UDP) 송수신에 대한 책임이 없다.
- 사용자는 하위 계층 패킷을 전송하는 방법을 정의하고 이를 콜백으로 KCP에 제공해야 한다.
- 시간도 외부에서 전달해야 한다. 내부적으로 시스템 호출이 한 번도 발생하지 않는다.
- 프로토콜 스택 위치
	<pre>
	프로토콜 스택 위치
	--------------------
	세션
	KCP(ARG)
	UDP(PACKET)
	IP
	LINK
	PHY
	</pre>
  
## 프로토콜 스택의 기본 기능 
TCP는 트래픽(초당 몇 킬로바이트의 데이터를 전송할 수 있는지)을 위해 설계 되었으며 대역폭을 최대한 활용gks다. KCP는 속도(하나의 패킷이 한쪽 끝에서 다른 쪽 끝으로 전송되는데 걸리는 시간)를 위해 설계 되었으며 TCP보다 전송 속도가 30~40% 빠른 대신 대역폭의 10%~20%를 낭비gks다.  
  
TCP 채널은 느리지만 초당 유속이 빠른 큰 운하인 반면, KCP는 유속이 빠른 작은 급류dl다. KCP는 일반 모드와 빠른 모드의 두 가지 모드가 있으며 다음과 같은 전략으로 유속을 증가시키는 결과를 얻는다.    
    
- RTO가 두 배가 된 경우와 두 배가 되지 않은 경우.  
>>> TCP 타임 아웃 계산은 RTOx2이므로 3회 연속 패킷 손실은 RTOx8이 되어 매우 무섭지만 KCP 시작 빠른 모드는 x2가 아니라 x1.5 (실험 결과 1.5 값이 상대적으로 좋은 것으로 나타남)로 전송 속도가 향상된다.   
- 선택적 재전송과 전체 재전송.  
>>> TCP는 패킷이 손실되면 손실된 패킷 이후의 모든 데이터를 재전송하지만, KCP는 실제로 손실된 패킷만 선택적으로 재전송한다(TCP도 SACK을 선택적으로 재전송하지만 차이가 있다).  
- 빠른 재전송.  
>>> 발신자가 패킷 1, 2, 3, 4, 5를 보낸 후 상대방으로부터 1, 3, 4, 5의 ACK를 받으면 KCP는 ACK 3을 받으면 2가 한 번 건너뛴 것을 알고, ACK 4를 받으면 2가 두 번 건너뛴 것을 알 수 있다. 이때 2가 손실된 것으로 간주하고 타임아웃을 기다리는 대신 패킷 2를 재전송하여 패킷 손실 시 전송 속도를 크게 향상시킨다. KCP는 각 ACK를 개별적으로 보내는 방식을 구현하지만 TCP는 이를 병합하는 방식으로 구현한다.  
- 지연된 ACK와 비지연 ACK.  
>>> TCP는 대역폭을 최대한 활용하기 위해 ACK 전송을 지연시키므로(노딜레이는 쓸모가 없음) 타임아웃 계산으로 인해 RTT 시간이 길어져 패킷 손실 시 판단 과정이 길어진다. KCP의 ACK 지연은 조정할 수 있다.    
- UNA와 ACK+UNA.
>>> ARQ 모델에는 두 가지 유형의 응답이 있다. UNA(이 번호까지의 모든 패킷이 수신됨, 예: TCP)와 ACK(이 번호의 패킷이 수신됨) UNA만 사용하면 완전한 재전송이 이루어지지만 ACK만 사용하면 손실이 너무 크다. 이전 프로토콜은 둘 중 하나를 사용했지만 KCP 프로토콜은 개별 ACK 패킷을 제외하고 모두에 대해 UNA 정보를 가지고 있다.  
- 비양보적 흐름 제어.  
>>> KCP 일반 모드는 공정 양보의 법칙, 즉 송신 버퍼의 크기, 수신 측의 남은 수신 버퍼의 크기, 패킷 손실 양보 및 네 가지 요소의 느린 시작에 의해 송신 창 크기가 결정되는 TCP와 동일하지만 높은 수준의 적시성이 필요한 작은 데이터를 전송할 때 BT를 원활하게 켜는 대신 후자의 두 단계를 건너 뛰고 처음 두 단계만 사용하여 일부 공정성과 대역폭 사용률을 희생하는 대신 전송 빈도를 제어하도록 구성을 선택할 수 있다. 그 결과 BT가 켜져 있어도 원활한 전송이 가능하다.  
  
  
## 기본 프로세스 
ARQ만으로는 실제로 모든 네트워크 시나리오를 충족할 수 없으며, 특히 네트워크가 혼잡할 경우 많은 재전송으로 인해 패킷 손실이 늘어날 수 있다.  
FEC를 추가하는 것은 현명한 선택이며, KCP 프로토콜은 KCP에 FEC를 추가하는 것을 배제하지 않는다.  
그러나 FEC 재전송은 패킷 지연 및 지터를 유발할 수 있으며, FEC로 디코딩된 패킷이 재전송 또는 네트워크 지연을 통해 도착하는 경우 애플리케이션 계층에서 이를 감지하여 중복된 패킷이 많아져 KCP의 전송 효율에 영향을 미치지 않도록 해야 한다는 점에 유의해야 한다.  
  
순서도는 rp 파일 참조  
  
ikcp_create를 통해 KCP 객체를 생성한다.  
각 세션마다 다른 객체가 생성된다.    
KCP 프로토콜 자체는 네트워크 코드를 제공하지 않으므로 KCP에서 UDP 전송 함수에 대한 콜백을 설정하고 필요할 때 콜백을 호출해야 한다.  
  
또한 KCP는 외부 메모리 할당 및 로깅 콜백을 지원하여 사용자에게 많은 자유를 제공한다.  
  
전체 KCP 프로토콜은 알고리즘을 구동하기 위해 단일 루프인 ikcp_update에 의존한다. 모든 데이터 송수신 및 상태 변경은 이 루프에 의존하므로 각 업데이트 주기를 너무 많이 차지하거나 내부 플러시 간격을 너무 크게 설정하는 작업은 알고리즘의 효율성을 떨어뜨릴 수 있다. 이는 데이터, 승인 패킷, 창 프로브 및 응답을 상대방에게 보내는 프로토콜의 핵심 기능이다.  
  
KCP는 ikcp_send를 사용하여 데이터를 전송한다. 이 함수는 데이터를 전송하기 위해 ikcp_output을 호출하며, 실제로는 미리 등록된 전송 콜백을 호출하여 데이터를 전송한다.  
KCP는 ikcp_recv를 통해 데이터를 수신한다. 데이터가 조각으로 전송된 경우 여기에서 자동으로 재조립되며 데이터는 전송 전과 동일하게 유지된다.  
  
  
## 데이터 구조 
기본 구조는 다음과 같다.  

0               4     5   6       8 (BYTE)
+------------ +----+---+-----+
|     conv      |cmd|frg | wnd |
+---------------+---+---+----+   8
|     ts          |     sn           |
+------------- +---------------+  16
|     una        |     len           |
+--------------+---------------+  24
|                                     |
|        DATA (optional)         |
|                                     |
+-------------------------------+  
    
코드이다.  
```
struct IKCPSEG
{
	struct IQUEUEHEAD node;
	IUINT32 conv;
	IUINT32 cmd;
	IUINT32 frg;
	IUINT32 wnd;
	IUINT32 ts;
	IUINT32 sn;
	IUINT32 una;
	IUINT32 len;
	IUINT32 resendts;
	IUINT32 rto;
	IUINT32 fastack;
	IUINT32 xmit;
	char data[1];
};
```  
  
- 변환: 32비트 4바이트  
>>> 세션의 수를 나타내는 정수로, 상호 패킷을 수락하려면 양 당사자가 모두 conv가 동일한지 확인해야 한다. conv는 세션을 고유하게 식별하지만, 두 당사자 사이에 동시에 둘 이상의 세션이 존재할 수 있다.  

- cmd 8비트 1바이트  
  슬라이스의 역할을 구분하는 데 사용된다.
  - IKCP_CMD_PUSH: 데이터 슬라이싱
  - IKCP_CMD_ACK: ack 슬라이싱
  - IKCP_CMD_WASK: 창 크기 알림 요청
  - IKCP_CMD_WINS: 창 크기를 알려준다.  
    
- frag 8비트 1바이트  
>>> 사용자 데이터는 여러 개의 KCP 패킷으로 전송될 수 있다. 프래그는 세그먼트 세그먼트 ID를 식별한다(메시지의 인덱스가 가장 큰 것부터 가장 작은 것까지 0은 마지막 세그먼트를 나타냄).  
  
- wnd 16비트 2바이트
>>> 남은 수신 창 크기(수신 창 크기 - 수신 대기열 크기) 발신자의 전송 창은 수신자가 지정한 값을 초과할 수 없다.  
  
- ts 32비트 4바이트  
>>> 메시지가 전송된 순간의 타임스탬프  
  
- sn 32비트 4바이트  
>>> 메시지 슬라이스 세그먼트의 일련 번호(1씩 증가)이다.  
  
- 32비트 4바이트  
>>> 보류 중인 메시지 번호(수신 슬라이딩 창의 왼쪽 끝) una는 패킷이 손실되지 않은 네트워크의 다음 수신 가능 번호이다(예: sn=10으로 수신된 패킷의 경우 una는 11).  
  
- len 32비트 4바이트  
>>> 데이터 길이  
  
- 재전송
>>> 다음 타임아웃 재전송을 위한 타임스탬프   
  
- rto  
>>> 이 슬라이스에 대한 타임아웃 재전송 대기 시간은 TCP와 동일한 방식으로 계산된다.  
  
- fastack
>>> 슬라이스를 건너뛴 누적 횟수(확인 수신 시 계산됨) 이 필드는 빠른 재전송에 사용된다. 빠른 재전송을 시작하는데 필요한 확인 횟수를 사용자 지정한다.  
  
- xmit  
>>> 슬라이스가 전송되는 횟수에 전송될 때마다 1을 더한 횟수 전송 횟수는 RTO 계산에 영향을 미치지만 TCP 보다는 덜하다.  
  
  
## IKCPCB 구조체
    
```	
struct IKCPCB
{
	IUINT32 conv, mtu, mss, state;
	IUINT32 snd_una, snd_nxt, rcv_nxt;
	IUINT32 ts_recent, ts_lastack, ssthresh;
	IINT32 rx_rttval, rx_srtt, rx_rto, rx_minrto;
	IUINT32 snd_wnd, rcv_wnd, rmt_wnd, cwnd, probe;
	IUINT32 current, interval, ts_flush, xmit;
	IUINT32 nrcv_buf, nsnd_buf;
	IUINT32 nrcv_que, nsnd_que;
	IUINT32 nodelay, updated;
	IUINT32 ts_probe, probe_wait;
	IUINT32 dead_link, incr;
	struct IQUEUEHEAD snd_queue;
	struct IQUEUEHEAD rcv_queue;
	struct IQUEUEHEAD snd_buf;
	struct IQUEUEHEAD rcv_buf;
	IUINT32 *acklist;
	IUINT32 ackcount;
	IUINT32 ackblock;
	void *user;
	char *buffer;
	int fastresend;
	int fastlimit;
	int nocwnd, stream;
	int logmask;
	int (*output)(const char *buf, int len, struct IKCPCB *kcp, void *user);
	void (*writelog)(const char *log, struct IKCPCB *kcp, void *user);
};
```  
  
IKCPCB는 KCP에서 가장 중요한 구조체이며 세션이 시작될 때 세션을 나타내기 위해 생성되는 객체이다.  
- conv: 세션을 식별한다.
- MTU: 최대 전송 단위 기본 데이터는 1400 이며 최소값은 50 이다.
- MSS: 최대 슬라이스 크기가 MTU보다 크지 않음
- 상태: 연결 상태(0xFFFFFFFF는 연결이 끊어졌음을 의미)
- snd_una: 첫 번째 미확인 패키지
- snd_nxt: 다음에 배포할 패킷의 일련 번호
- RCV_NEXT: 수신할 메시지 번호 패킷 순서를 보장하기 위해 수신기는 시작 번호인 RCV_NEXT(수신할 메시지 번호)와 끝 번호인 RCV_NEXT + RCV_WND(수신 창 크기)가 있는 수신 창을 유지한다.
- ssthresh: 혼잡 창 임계값 패킷 단위(TCP 바이트)
- rx_rttval: RTT의 변화량 연결의 지터를 나타낸다.
- RX_SRTT: 평활화된 왕복 시간 평활화된 포스트 RTT
- RX_RTO: ACK 수신 지연에서 계산된 재전송 시간 제한
- rx_minrto: 최소 재전송 시간 제한
- snd_wnd: 전송 창 크기
- RCV_WND: 수신 창 크기
- rmt_wnd: 원격 수신 창 크기
- CWND: 혼잡 창 크기
- 프로브: 프로브 변수 IKCP_ASK_TELL은 원격에 창 크기를 알려주는 것을 의미한다. IKCP_ASK_SEND는 원격에 창 크기를 알려달라고 요청하는 것을 의미한다.
- 간격: 시스템 루프 효율성에 매우 중요한 내부 플러시 간격
- ts_flush: 다음 플러시 새로 고침의 타임스탬프
- xmit: 세그먼트가 전송되는 횟수(최초 또는 재전송 제외)가 증가하면 세그먼트 xmit도 증가한다.
- rcv_buf: 수신 메시지 버퍼
- nrcv_buf: 수신 캐시에 있는 메시지 수
- snd_buf: 메시지 전송을 위한 캐시
- NSND_BUF: 전송 캐시에 있는 메시지 수
- rcv_queue: 메시지 수신 대기열
- nrcv_que: 수신 대기열에 있는 메시지 수
- snd_queue: 메시지 전송 대기열
- nsnd_que: 전송 대기열에 있는 메시지 수
- 노데일: 노데일 모드 활성화 여부 노데일 모드 r토민은 0으로 설정된다. 혼잡 제어가 활성화되지 않는다.
- 업데이트됨: 업데이트 함수가 호출되었는지 여부를 나타낸다.
- ts_probe: 다음 프로브 창의 타임스탬프
- 프로브_대기: 프로브 창이 열릴 때까지 기다리는 시간
- dead_link: 끊어진 링크로 간주되는 최대 재전송 횟수
- incr: 전송할 수 있는 최대 데이터 양
- acklist: 전송할 ack 목록
- ackcount: 어카운트 목록에 있는 어카운트 수 각 어카운트는 어카운트 목록에 두 개의 ts sn 수량을 저장한다.
- ackblock: 2의 배수 아크 리스트가 보유할 수 있는 최대 아크 수를 식별한다.
- user: 사용자를 대신하여 임의의 데이터를 배치하고 프로그램에서 전달해야 하는 변수를 설정하는 데 사용할 수 있는 포인터이다.
- buffer: 메시지 바이트 스트림을 저장한다.
- fastresend: 빠른 재전송을 트리거하는 중복 ACK 수
- nocwnd: 혼잡 제어를 취소한다.
- stream: 스트리밍 모드 사용 여부
- logmask: 로그 유형(예: 디버깅 목적의 IKCP_LOG_IN_DATA)
- output UDP: 메시지 전송을 위한 콜백 함수
- writelog: 로그 작성을 위한 콜백 함수  
  
  
## 기본 사용 
1. KCP 객체를 생성한다:  
```
ikcpcb *kcp = ikcp_create(conv, user);
```  
  
2. 콜백 함수를 설정힌다:  
```
int udp_output(const char *buf, int len, ikcpcb *kcp, void *user)
{
  ....
}

kcp->output = udp_output;
```  
  
3. 재귀적 호출로 업데이트:  
```
ikcp_update(kcp, millisec);
```  
  
4. 하위 계층 패킷을 입력한다:  
```
ikcp_input(kcp, received_udp_packet, received_udp_size);
```  
  
하위 프로토콜의 출력/입력을 처리한 후 KCP 프로토콜은 정상적으로 작동한다.  
ikcp_send를 사용하여 원격 측에 데이터를 전송한다.  
상대방은 ikcp_recv(kcp, ptr, size)를 사용하여 데이터를 수신한다.  
  
  
## 프로토콜 구성 
프로토콜의 기본 모드는 다양한 가속 스위치를 켜도록 구성해야 하는 표준 ARQ이다:  
  
1. 작업 모드:  
```
int ikcp_nodelay(ikcpcb *kcp, int nodelay, int interval, int resend, int nc)
```  
- 노드레이: 노드레이 모드 활성화 여부 0 활성화되지 않음, 1 활성화됨
- 간격: 프로토콜 내부 작업의 밀리초 단위 간격(예: 10ms 또는 20ms)이다.
- 재전송 ： 빠른 재전송 모드 기본값 0 꺼짐 2로 설정 가능 (2 ACK 교차 시 바로 재전송)
- NC: 흐름 제어 비활성화 여부 기본값은 비활성화 안 함 0 비활성화 됨 1 비활성화 됨
- 일반 모드: ICP_NODELAY(KCP, 0, 40, 0, 0).
- 익스트림 모드: ikcp_nodelay(kcp, 1, 10, 2, 1).
  
2. 최대 창:   
```
int ikcp_wndsize(ikcpcb *kcp, int sndwnd, int rcvwnd);
```  
이 호출은 프로토콜의 최대 전송 및 수신 창 크기를 기본적으로 32로 설정한다. 이는 단위가 다르다는 점을 제외하면 TCP의 SND_BUF 및 RCV_BUF와 비슷하다고 생각할 수 있다. SND/RCV_BUF는 바이트 단위이며, 이것은 패킷 단위이다.  
  
3. 최대 전송 단위:  
순수 알고리즘 프로토콜은 MTU를 감지할 책임이 없다. 기본 MTU는 1400 바이트이다. 이 값은 ikcp_setmtu를 사용하여 설정할 수 있다. 이 값은 패킷이 병합 및 조각화될 때 최대 전송 단위로 영향을 준다.  
  
4. 최소 RTO:  
기본 RTO가 100 밀리초이기 때문에 계산된 RTO가 40 밀리초인 경우에도 프로토콜은 고속 모드에서 100 밀리초 30 밀리초 이후에만 패킷 손실을 감지할 수 있다. 이 값을 수동으로 변경할 수 있다:  
```
kcp->rx_minrto = 10;
```  
  
  
## 캐시 누적 지연 시간 방지 
TCP를 사용하든 KCP를 사용하든 채널 제한을 초과하여 데이터를 전송할 수 없다. TCP의 경우 전송 창 SNDBUF에 따라 한 번에 전송할 수 있는 데이터의 양이 결정되며, KCP도 마찬가지이다.  
  
현재 전송 중이고 ACK/UNA로 확인되지 않은 데이터는 전송 버퍼에 남아 있다. 남아 있는 데이터가 전송 창 크기 제한을 초과하면 링크에 대한 tcp 전송 호출이 차단되거나 반환된다. 즉, 현재 사용 가능한 tcp 채널의 대역폭이 더 이상 전송 속도를 따라잡을 수 없음을 의미하는 EAGAIN / EWOULDBLOCK이 발생한다.  
```
可用带宽 = min(本地可用发送窗口大小，远端可用接收窗口大小) * (1 - 丢包率) / RTT
```  
ikcp_send를 연속적으로 호출하면 먼저 kcp의 snd_buf를 채우고, snd_buf의 크기가 전송 윈도우 snd_wnd 제한을 초과하면 snd_buf에 패킷 추가를 중지하고 snd_queue 안에만 넣고 대기하면서 snd_buf에 새로운 위치가 생길 때까지 기다린다 (원-엔드 ack/una 수신으로 인해 히스토리 패킷이 제거되고 snd_buf의 새 위치가 생기면(역방향 ack/una 수신으로 인해 히스토리 패킷이 snd_buf에서 제거됨), snd_queue에서 snd_buf로 전송되어 전송되기를 기다린다.  
  
TCP 전송 창이 꽉 차서 전송할 수 없는 경우 차단하거나 EAGAIN/EWOULDBLOCK 하고, KCP 전송 창이 꽉 차면 ikcp_send는 -1을 반환하지 않고 데이터가 snd_queue에 남아서 다시 전송할 수 있을 때까지 기다린다.  
  
그렇다면 ikcp_send가 제어할 수 없이 호출될 수 있다고 생각하지 마시고, 왜 전송 창이 꽉 찼을 때 KCP가 오류를 반환하지 않을까? 이 문제는 절충안이 설계되었을 때, 오류의 반환을 희망으로 다시 보내려면 EAGAIN/EWOULDBLOCK 당신은 또한 당신이 보낼 수 있는지 여부를 테스트 할 다음 시간까지 외부 계층에 바인딩되어 캐시를 만들어야한다. 그러면 더 간단한 상위 계층이 할 수 있도록이 계층의 캐시를 직접 kcp 하는 것이 더 좋으며, EAGAIN을 처리하는 방법은 상위 계층이 ikcp_waitsnd 함수를 사용하여 전송되지 않은 패킷 수를 결정하고 snd_queue 캐시 또는 기타에 패킷을 추가할지 여부를 유연하게 결정할 수 있다.  
  
  
## 창 크기 재설정 
위의 문제를 해결하려면 먼저 대역폭 사용량을 예측하고 위의 공식에 따라 송신 창과 수신 창의 크기를 재설정하고 백엔드를 작성하고 tcp의 성능을 추구하려면 tcp의 sndbuf, rcvbuf의 크기도 재설정 해야하며, 기본 전송 창 및 수신 창 크기는 상대적으로 작으며 (기본적으로 32 패킷) 64, 128, 256, 512, 1024 등으로 상향 조정할 수 있다. kcptun 기본 전송 창 1024는 HD 비디오 전송에 충분하고 32-256은 게임에 충분해야한다. 128, 256, 512, 1024 등, kcptun 기본 전송 창은 1024로 HD 비디오 전송에 충분하며 게임의 경우 32-256이면 충분하다.  
  
설정하지 않으면 기본 snd_wnd가 너무 작고 네트워크가 원활하지 않은 경우 점점 더 많은 데이터가 전송되지 않고 snd_queue에 묶이게 되어 지연 시간이 점점 더 길어진다.  
  
snd_wnd가 설정된 경우, 발신자 측의 snd_wnd 크기보다 작지 않도록 원격 rcv_wnd를 적절히 확장해야 하며, 그렇지 않으면 설정이 의미가 없다.  
  
둘째, 성숙한 백엔드 서비스의 경우 TCP를 사용하든 KCP를 사용하든 관련 캐시 제어 정책을 구현해야 한다:  
  
  
## 캐시 제어: 파일 전송 
tcp를 사용하여 파일을 전송하는 경우 네트워크가 무력화 되면 전송 호출이 차단되거나 EAGAIN 되며, 다음 번에 전송을 계속할 수 있는 시점을 결정하려면 epoll을 통해 EPOLL_OUT 이벤트를 확인해야 한다.  
  
KCP에도 동일하게 적용되며, ikcp_waitsnd가 임계값을 초과하면(예: 2x snd_wnd) ikcp_send 호출이 중지되고 ikcp_waitsnd의 값이 낮아지며, 그 동안 ikcp_update 호출은 계속 진행된다.  
  
  
## 캐시 제어: 라이브 비디오 스트리밍 
주문형 비디오는 파일 전송과 동일하지만, 라이브 비디오의 경우 ikcp_waitsnd가 임계값을 초과하면 더 이상 새로운 패킷을 kcp로 보내지 않을 뿐만 아니라 ikcp_waitsnd가 임계값의 1/2로 줄어들 때까지 비디오가 "드롭된 프레임" 상태가 되어야 비디오에 지연이 지연이 누적되지 않도록 한다.  
   
이는 TCP를 사용하여 스트림을 푸시할 때 EAGAIN 기간 동안 프레임을 적극적으로 드롭하는 것과 동일한 로직이다.  
  
한편, 대기 시간이 임계값을 초과하면 네트워크 전송 용량이 일정 시간 동안 감소했음을 의미하며, 이 경우 동영상 품질을 동적으로 낮추고 비트 전송률을 줄인 다음 네트워크가 복구되면 다시 복원할 수 있다.  
  
  
## 캐시 제어: 게임 제어 데이터 
엄격한 TCP 게임 서버의 대부분의 로직은 사용자에게 데이터를 보내는 백엔드 비즈니스가 EPOLL_OUT 이벤트(즉, tcp 전송 버퍼가 비어있는 경우, 즉, EAGAIN/EWOULDBLOCK 시간이 아닌)에 대한 epoll이 발생하면 링 버퍼 등과 같은 전송 버퍼의 일부가 사용자의 공간에 추가되고, 전송을 사용하여 임시 데이터 내부의 링 버퍼가 다시 EAGAIN/EWOULDBLOCK 까지 시스템 SNDBUF로 전달 될 때 비 차단 tcp 링크를 사용하여 데이터를 전송하는 것이다. EAGAIN/EWOULDBLOCK, 링 버퍼에 저장된 데이터를 다시 EAGAIN까지 시스템의 SNDBUF로 전송한다.  
  
따라서 TCP 서버의 백엔드 비즈니스는 계속해서 클라이언트에 데이터를 보내고 클라이언트는 지연을 어떻게 수신 할 수 없을까? 이 시점에서 epoll은 오랫동안 epoll_out 이벤트를 반환하지 않으며, 데이터는 사용자의 링 버퍼에 쌓이고, 점점 더 쌓이면 링 버퍼가 자체 성장하면 서버의 메모리가 소진된다. 따라서 성숙한 tcp 게임 서버의 관행은 클라이언트의 응용 프로그램 계층 전송 버퍼 (non-tcp sndbuf)에서 전송할 데이터가 특정 임계 값을 초과하면 사용자가 수신 할 수 없기 때문에 TCP 링크가 끊어지고 게임 데이터를 계속 수신 할 수 없게 된다.  
  
KCP를 사용하여 게임 데이터를 전송할 때도 마찬가지로, ikcp_waitsnd 반환값이 특정 한도를 초과하면 더 이상 수신할 수 없으므로 원격 링크를 끊어야 한다.  
  
단, KCP의 기본 창은 32로 tcp의 기본 창보다 훨씬 낮으므로 실제 창 사용은 미리 조정해야 하지만 공정성을 위해 끝없이 확대하지 않아야 한다(1024를 초과하지 않음).  
  
  
## 요약 
캐시 누적 문제는 TCP든 KCP든 처리해야 하는 문제인데, TCP의 기본 창이 더 크기 때문에 많은 사람이 처리할 수 있는 수준은 아닐 것이다.  
  
캐시 지연이 발생하는 경우:  
1. 위의 공식 변환에 따라 초당 몇 개의 패킷을 전송해야 하는지, 현재 snd_wnd, rcv_wnd의 값이 요구 사항을 충족하는지, 현재 snd_wnd가 조건을 충족하는지 확인한다.  
2. 가속 기능이 작동할 수 있도록 ikcp_nodelay가 켜져 있는지 확인하고, 기본 tcp와 같은 보수적인 흐름 제어 방법을 비활성화하도록 nc 매개변수가 설정되어 있는지 확인한다.  
3. ikcp_update 호출 빈도가 요구 사항을 충족하는지 확인한다(예: 10ms에 한 번).  
  
그래도 더 공격적으로 활동하고 싶다면:  
  
1. 예를 들어 minrto가 10ms로 설정되어 있는지, nodelay가 방금 30ms로 설정되어 있는지, 또는 더 적극적으로 10ms 또는 5ms로 설정되어 있는지 확인한다.  
2. 간격이 설정되어 있는지 확인하고 더 공격적으로 5ms로 설정하여 내부 항상 루프를 더 빠르게 만들 수 있다.  
3. 각 패킷을 전송한 후 수동으로 ikcp_flush를 호출한다.  
4. MTU를 470으로 낮추면 동일한 데이터가 더 많은 패킷으로 전송되지만 라우팅 계층에서 더 작은 패킷의 우선 순위가 높아진다.    
  
그래도 더 빠른 속도를 원한다면 KCP의 하위 계층에 순방향 오류 수정 프로토콜을 추가할 수 있다. 자세한 내용은 프로토콜 계층화, 모범 사례를 참조한다.  

